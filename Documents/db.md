<link rel="stylesheet" href="../lib/font-awesome-4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href=../lib/my.css>

<a href="#top"><i class="fa fa-angle-up fa-3x button"></i></a>

### <a id='top' href="../README.md">数据库面试必考<i class="fa fa-reply" aria-hidden="true"></i></a>
星期一, 07. 八月 2017 09:23上午 
### 1.什么是存储过程？有哪些优缺点？
存储过程是一些预编译的SQL语句。

更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。

存储过程是一个预编译的代码块，执行效率比较高
一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率
可以一定程度上确保数据安全,保证数据库完整性

---
### 2.索引是什么？有什么作用以及优缺点？
数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。

在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。

创建索引可以大大提高系统的性能（优点）：

第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。

第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。

第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，为表设置索引要付出代价的，一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。增加索引也有许多不利的方面：

第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。

第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。

第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。
一般来说，应该在这些列上创建索引：

（1）在经常需要搜索的列上，可以加快搜索的速度；

（2）在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；

（3）在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；

（4）在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；

（5）在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；

（6）在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。

同样，对于有些列不应该创建索引：

第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。

第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。

第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。

第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。

---
### 3.什么是事务？事务的四个特性及含义？什么是锁？
事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。

原子性(Atomicity)：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

一致性(Consistency)：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。

隔离性(Isolation)：隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。

持久性(Durability)：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

锁：在所有的 DBMS 中，锁是实现事务的关键，锁可以保证事务的完整性和并发性。与现实生活中锁一样，它可以使某些数据的拥有者，在某段时间内不能使用某些数据或数据结构。当然锁还分级别的。
---
### 4.数据库的乐观锁和悲观锁是什么？
数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。

乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作

乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

---
### 5.简单说一说`drop`、`delete`与`truncate`的区别、分别在什么场景之下使用？
SQL中的drop、delete、truncate都表示删除，但是三者有一些差别

delete和truncate只删除表的数据不删除表的结构

速度,一般来说: drop> truncate >delete 

delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;

如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger. 

1）不再需要一张表的时候，用drop

2）想删除部分数据行时候，用delete，并且带上where子句

3）保留表而删除所有数据的时候用truncate

---
### 6.超键、候选键、主键、外键分别是什么？
超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。

候选键：是最小超键，即没有冗余元素的超键。

主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。

外键：在一个表中存在的另一个表的主键称此表的外键。

---
### 7.什么是视图？以及视图的使用场景有哪些？
视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。

（1）不希望访问者获取整个表的信息，只暴露部分字段给访问者，所以就建一个虚表，就是视图。

（2）查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异。

---
### 8.说一说三个范式。
第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。

第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。

第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在"A → B → C"的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y

---
### 9.触发器的作用？
触发器： 当满足触发器条件，则系统自动执行触发器的触发体。

触发时间：有before,after.触发事件：有insert,update,delete三种。触发类型：有行触发、语句触发

触发器是一中特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。

---
### 10.维护数据库的完整性和一致性，你喜欢用触发器还是自写业务逻辑？为什么？
尽可能使用约束，如 check, 主键，外键，非空字段等来约束，这样做效率最高，也最方便。其次是使用触发器，这种方法可以保证，无论什么业务系统访问数据库都可以保证数据的完整性和一致性。最后考虑的是自写业务逻辑，但这样做麻烦，编程复杂，效率低下。

---

 数据库系统的特点
 1.数据结构化
 2.数据的共享性高,冗余度低,易扩充
 3.数据独立性高
 4.数据由DBMS统一管理和控制(数据的安全性保护,数据的完整性检查,并发控制,数据库恢复)

 数据模型
数据模型也是一种模型,它是对现实世界数据特征的抽象,也就是说,数据模型是用来描述数据,组织数据,和对数据进行操作的.

两类数据模型:
第一类概念模型,也成为信息模型,它是按用户的观点来对数据和信息建模,主要用于数据库设计.
第二类逻辑模型,主要包括层次模型,网状模型,关系模型,面向对象模型和对象关系模型

数据模型的组成要素
数据结构,数据操作,数据的完整性约束条件

实体-联系方法(E-R模型):一种概念模型的表示方法

数据库系统结构

数据库系统的三级模式结构:外模式,模式,内模式.
模式(Schema)也称逻辑模式,是数据库中全体数据的逻辑结构和特征的描述,它仅仅设计型的描述,不涉及具体的值.模式的一个具体值称为模式的一个实例,同一个模式可以有很多实例.模式是相对稳定的,而实例是相对变动的.一个数据库只有一个模式.DDL(模式描述语言)严格定义模式
外模式(External Schema)外模式也称子模式或用户模式,是数据库用户(包括应用程序员和最终用户)能够看见和使用的局部数据的逻辑结构和特征的描述,是数据库用户的数据视图,是与某一应用有关的数据的逻辑表示,一个数据库可以有多个外模式.DDL定义子模式
内模式(Internal Schema)也称存储模式,一个数据库只有一个内模式,它是数据物理结构和存贮方式的描述,是数据在数据库内部的表示方式.

数据库管理系统在三级模式之间提供了两层映像:外模式/模式映像,模式/内模式映像,正是这两层映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性.

关系模型的数据结构只包含单一的数据结构---关系,在用户看来,关系模型中的数据结构的逻辑结构是一张扁平的二维表

域:是一组具有相同数据类型的值的集合.
笛卡尔积:是域上面的一种集合运算.
关系:笛卡尔积的有限子集
候选码:若关系中的某一属性组的值能唯一的标识一个元组,则称该属性组为候选码
主码:若一个关系有多个候选码,则选定其中一个为主码.
主属性:候选码的诸属性成为主属性.
非主属性:不包含在任何候选码中的属性成为非主属性或非码属性.

关系可以有三种类型:基本关系(通常称为基本表或基表),查询表,视图表
基本表是实际存在的表,它是实际存储数据的逻辑表示
查询表是查询结果对应的表
视图表是由基本表或其他视图表导出的表,是虚表,不对应实际存储的数据.数据库中只存放视图的定义,而不存放视图对应的数据,这些数据仍然放在原来的基本表中

视图的作用:
1.视图能够简化用户的操作
2.视图能够是用户以多种角度看待同一数据
3.视图对重构数据库提供了一定成都的逻辑独立性
>数据库的逻辑结构改变了,但是用户使用的视图可以不变,也就是开放给用户的接口没有边
4.视图能够对机密数据提供安全保护
>不同的用户看到不同的数据
5.适当的利用视图可以更清晰的表达查询

关系的三类完整性约束:实体完整性,参照完整性,用户定义的完整性.
实体完整性:若属性(一个或一组属性)A是基本关系R的主属性,则A不能取空值
参照完整性:若属性(或属性组)F是基本关系R的外码,它与基本关系S的主码K相对性,则对于R中每个元组在F上的值必须为空值(F的每个属性值均为空值)或等于S中某个元组的主码值
用户定义的完整性:用户自己根据实际情况定义的完整性约束.

选择(Selection):又称为限制,它是在关系R中选择满足给定条件的诸元组.
投影(Projection):关系R上的投影是从R中选择出若干属性列组成新的关系,从列的角度进行运算
连接(Join):从两个关系的笛卡尔积中选取属性间满足一定条件的元组
等值链接,自然连接,一般的连接操作是从行的角度进行运算.自然连接还需要取消重复的列,所以是同时从行和列的角度进行运算.
除运算(Division):好复杂的表达式,看书吧...

SQL(Structured Query Language),结构化查询语言,是关系数据库的标准语言.
SQL集数据查询(Data Query),数据操纵(Data Manipulation),数据定义(Data Definition),数据控制(Data Control)功能于一体
SQL主要特点有:综合统一,高度非过程化,面向集合的操作方式,以同一种语法结构提供多种使用方式,语言简洁,易学易用.

实现数据库系统安全的计数重要的有存取控制技术,视图技术,审计技术
数据库角色是一组权限的集合,使用角色来管理数据库权限可以简化授权的过程.

数据的完整性是为了防止数据库中存在不符合语义的数据,也就是防止数据库中存在不正确的数据.
数据的安全性是保护数据库防止恶意的破坏和非法的存取.
完整性检查和控制的防范对象是不符合语义的,不正确的数据,防止它们进入数据库.
安全性控制防范的对象是非法用户和非法操作,防止他们对数据库的非法存取.

数据库完整性一般由SQL的DDL语句实现.它们作为数据库模式的一部分存入数据字典中,在数据修改时进行这些约束检查.
完整性约束影像系统性能.

触发器是实现数据库完整性的一个重要方法,它是定义在关系表上的由事件驱动的特殊过程,它功能非常强,不仅可以用于数据库完整性检查,还可以用来实现安全性,业务流程控制,控制流程等.

规范化:一个低一级范式的关系模式,通过模式分解可以转换成为若干个高一级范式的关系模式的集合,这个过程就叫规范化.

数据库设计的基本步骤:需求分析,概念结构设计,逻辑结构设计,物理结构设计,数据库实施,数据库运行和维护.

嵌入式SQL语句与主语言之间的通信:
向主语言传递SQL语句的执行状态信息,使主语言能够据此信息控制程序流程,主要用SQL通信区实现.
主语言向SQL语句提供参数,主要用主变量(Host Variable)实现
>SQL语句中使用的主语言程序变量简称为主变量.
将SQL语句查询数据库的结果交主语言处理,主要用主变量和游标实现

游标:是系统为用户开设的一个数据缓冲区,存放SQL语句的执行结果,每个游标去都有一个名字.用户可以通过游标逐一获取记录.
>SQL是面向集合的,一条SQL语句可以产生或处理多条记录,而主语言是面向记录的,一组主变量一次只能存放一条记录,所以引入了游标来协调这两种处理方式.

动态SQL:某些应用可能要到执行时才能够确定要提交的SQL语句,查询的条件,因此要使用动态SQL来解决这类问题.动态SQL方法允许在程序运行过程临时"组装"SQL语句.动态SQL支持动态组装SQL语句和动态参数两种形式.

PL/SQL是对SQL的扩展,使其增加了过程化语句功能.PL/SQL程序的基本结构是块,分为匿名块和命名块.
匿名块每次执行都要进行编译,不能存储在数据库中,也不能在其他块中调用.
存储过程和函数是命名块,它们别编译后保存在数据库中,可以被反复调用,运行速度较快.

关系数据库系统的查询处理步骤:查询分析,查询检查,查询优化,查询执行.

事务是一系列的数据库操作,是数据库应用程序的基本逻辑单元.
事务处理技术主要包括数据库恢复技术和并发控制技术.
数据库恢复机制和并发控制机制是数据库管理系统的重要组成部分.

事务的定义:事务是用户定义的一个数据库操作系列,这些操作要么全做要么全部做,是一个不可分割的工作单位.一个事务可以是一条SQL语句,一组SQL语句或整个程序.

事务和程序是两个概念,一般的一个程序中包含多个事务.

事务的开始与结束可以由用户显示的控制.如果用户没有显示的定义事务,则由DBMS按缺省规定自动划分事务
BEGIN TRANSACTION//开始事务
COMMIT或者ROLLBACK结束事务.

数据库管理系统把数据库从错误状态恢复到某一已知的正确状态(亦称为一致状态或完整状态)的功能就是数据库恢复.

数据库故障的种类:事务内部的故障,系统故障,介质故障,计算机病毒

数据恢复的原理十分简单:冗余

恢复机制涉及两个关键问题:如何建立冗余数据,如何利用这些冗余数据实施数据恢复.

建立冗余数据最常用的技术是数据转储和登录日志文件,通常两者一起使用.

静态转储:在系统中无运行事务时进行的转储操作.会降低数据库的可用性
动态转储:转储期间允许对数据库进行存取或修改,即转储和用户事务可以并发执行.转储后的副本不能保证正确有效,因此需要建立日志文件,通过副本加日志文件一起进行恢复.

日志文件的作用:1.事务故障恢复和系统故障恢复必须使用日志文件.2.在动态转储方式中必须建立日志文件,后备副本和日志文件结合起来才能有效的恢复数据库.3.在静态转储方式中,也可以建立日志文件.

登记日志文件需要遵循两条原则:1.登记的次序严格按并发事务执行的时间次序;2.必须先写日志文件,后写数据库.

数据库恢复策略:
事务故障的恢复:根据日志文件撤销(UNDO)事务
系统故障:正向扫描日志文件,找到故障前已经提交的和没有提交的事务,重做已经提交的事务,撤销没有提交的事务.
介质故障的恢复:根据数据库后备副本和日志文件进行恢复.

事务的隔离级别:
丢失修改(Lost Update):两个事务T1和T2读入统一数据并修改,T2提交的结果破坏了T1提交的结果,导致T1的修改被丢失.
不可重复读(Non-Repeatable Read):事务T1读取数据后,事务T2执行更新操作,使T1无法再现前一次读取的结果.
>不可重复读的三种情况:1.事务T1读取某一数据后,事务T2对数据做了修改,当事务T1再次读该数据时,得到与前一次不同的值,称为虚读.2.事务T1按一定条件从数据库中读取了某些数据记录后,事务T2删除了其中部分记录,当T1再次按相同条件读取数据时,发现某些记录神秘的消失了(幻读);3.事务T1按一定条件从数据库中读取某些数据记录后,事务T2插入了一些记录,当T1再次按相同条件读取数据时,发现多了一些记录.(幻读)
读"脏"数据(Dirty Read):事务T1修改某一数据,并将其写回磁盘,事务T2读取同一数据后,T1由于某种原因被撤销,这时T1已经修改过的数据恢复原值,T2读到的数据就与数据库中的数据不一致.

并发控制的主要技术有封锁(Locking),时间戳(Timestamp),乐观控制法.
封锁是实现并发控制的一个非常重要的技术.

基本的封锁类型有两种:排它锁(Exclusive Locks,X锁),共享锁(Share Locks,S 锁)
排它锁也称为写锁.若事务T对数据对象A加上X锁,则只允许T读取和修改A,其他任何事务都不能再对A加任何类型的锁,直到T释放A上的锁.
共享锁也称为读锁,若事务T对数据对象A加上S锁,则事务T可以读A但不能修改A,其他事务只能再对A加S锁,而不能加X锁,直到T释放A上的S锁.

和操作系统一样,封锁的方法可能引起活锁和死锁等问题.
活锁对应操作系统的饥饿.采用先来先服等策略避免活锁.

死锁的预防:
一次封锁,要求事务一次性对需要的所有数据加锁.扩大了封锁范围,降低系统并发度;无法精确确定需要封锁的对象.
顺序封锁法,预先对数据对象规定一个封锁顺序,所有事务都按这个顺序实行封锁.维护成本高,也很难按规定顺序去加锁.

可串行化调度:多个事务的并发执行是正确的,当且仅当其结果与按某一次序串行地执行这些事务时的结果相同,称这种调度策略为可串行化的调度.

两段锁协议(Two-Phase Locking):实现并发调度的可串行性,从而保证调度的正确性.
所谓两段锁协议是指所有事务必须分两个阶段对数据项加锁和解锁:在对任何数据进行读写操作之前,首先要申请并获得对该数据的封锁;在释放一个封锁之后,事务不再申请和获得任何其他封锁.
第一阶段获得封锁,也称为扩展阶段,在这一阶段事务可以申请获得任何数据项上的任何类型的锁,但是不能释放任何锁.第二阶段是释放封锁,也称为收缩阶段,在这一阶段,事务可以释放任何数据项上的任何类型的锁,但是不能再申请任何锁.

两段锁协议是可串行化的充分条件,但不是必要条件.

封锁的粒度:封锁对象的大小称为封锁粒度(Granularity).
封锁对象可以是逻辑单元,也可以是物理单元.
关系数据库中,封锁对象可以是属性值,属性值的集合,元组,关系,索引项,整个索引直至真个数据库等逻辑单元,也可以是页,物理记录等物理单元.

封锁的粒度越大,数据库能够封锁的数据单元越少,并发度就越少,系统开销也越小.
封锁的粒度越小,数据库能够封锁的数据单元越多,并发度就越多,系统开销也越大.

由于多粒度封锁协议带来的隐式封锁问题,引进了意向锁(Intention Lock);
对任一节点加锁时,必须先对它的上层节点加意向锁.

意向共享锁(Intent Share Lock,IS锁),意向拍它锁(Intent Exclusive Lock,IX),共享意向拍它锁(Share Intent Exclusive Loxk,SIX)

