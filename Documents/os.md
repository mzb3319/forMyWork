<link rel="stylesheet" href="../lib/font-awesome-4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href=../lib/my.css>

<a href="#top"><i class="fa fa-angle-up fa-3x button"></i></a>

### <a id='top' href="../README.md">操作系统面试必考<i class="fa fa-reply" aria-hidden="true"></i></a>
### 1.什么是进程（Process）和线程（Thread）？有何区别？
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。

进程与应用程序的区别在于应用程序作为一个静态文件存储在计算机系统的硬盘等存储空间中，而进程则是处于动态条件下由操作系统维护的系统资源管理实体。

---
### 2.Windows下的内存是如何管理的？
Windows提供了3种方法来进行内存管理：

虚拟内存:最适合用来管理大型对象或者结构数组；

内存映射文件:最适合用来管理大型数据流（通常来自文件）以及在单个计算机上运行多个进程之间共享数据；

内存堆栈:最适合用来管理大量的小对象。

Windows操纵内存可以分两个层面：物理内存和虚拟内存。

其中物理内存由系统管理，不允许应用程序直接访问，应用程序可见的只有一个2G地址空间，而内存分配是通过堆进行的。对于每个进程都有自己的默认堆，当一个堆创建后，就通过虚拟内存操作保留了相应大小的地址块（不占有实际的内存，系统消耗很小）。当在堆上分配一块内存时，系统在堆的地址表里找到一个空闲块（如果找不到，且堆创建属性是可扩充的，则扩充堆大小），为这个空闲块所包含的所有内存页提交物理对象（在物理内存上或硬盘的交换文件上），这时就可以访问这部分地址。提交时，系统将对所有进程的内存统一调配，如果物理内存不够，系统试图把一部分进程暂时不访问的页放入交换文件，以腾出部分物理内存。释放内存时，只在堆中将所在的页解除提交（相应的物理对象被解除），继续保留地址空间。

如果要知道某个地址是否被占用/可不可以访问，只要查询此地址的虚拟内存状态即可。如果是提交，则可以访问。如果仅仅保留，或没保留，则产生一个软件异常。此外，有些内存页可以设置各种属性。如果是只读，向内存写也会产生软件异常。

---
### 3.Windows消息调度机制是？
消息队列。

处理消息队列的顺序。首先Windows绝对不是按队列先进先出的次序来处理的，而是有一定优先级的。优先级通过消息队列的状态标志来实现的。首先，最高优先级的是别的线程发过来的消息（通过sendmessage）；其次，处理登记消息队列消息；再次处理QS_QUIT标志，处理虚拟输入队列，处理wm_paint；最后是wm_timer。

---
### 4.描述实时系统的基本特性
在特定时间内完成特定的任务，实时性与可靠性。

所谓“实时操作系统”，实际上是指操作系统工作时，其各种资源可以根据需要随时进行动态分配。由于各种资源可以进行动态分配，因此，其处理事务的能力较强、速度较快。

---
### 5.什么是中断？中断和轮询的特点
对I/O设备的程序轮询的方式，是早期的计算机系统对I/O设备的一种管理方式。它定时对各种设备轮流询问一遍有无处理要求。轮流询问之后，有要求的，则加以处理。在处理I/O设备的要求之后，处理机返回继续工作。尽管轮询需要时间，但轮询要比I/O设备的速度要快得多，所以一般不会发生不能及时处理的问题。当然，再快的处理机，能处理的输入输出设备的数量也是有一定限度的。而且，程序轮询毕竟占据了CPU相当一部分处理时间，因此，程序轮询是一种效率较低的方式，在现代计算机系统中已很少应用。

程序中断通常简称中断，是指CPU在正常运行程序的过程中，由于预先安排或发生了各种随机的内部或外部事件，使CPU中断正在运行的程序，而转到相应的事件处理程序。待处理完毕后又返回原来被中断处继续执行或调度新的进程执行的过程。

轮询——效率低，等待时间很长，CPU利用率不高。

中断——容易遗漏一些问题，CPU利用率高。

---
### 6.什么是临界区？如何解决冲突？
每个进程中访问临界资源的那段程序称为临界区，每次只准许一个进程进入临界区，进入后不允许其他进程进入。

（1）如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入；

（2）任何时候，处于临界区内的进程不可多于一个。如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待；

（3）进入临界区的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区；

（4）如果进程不能进入自己的临界区，则应让出CPU，避免进程出现“忙等”现象。

---
### 7.分段和分页
>(mzb)可以比做一个笔记本，笔记本的大小是固定的，每页可以放下固定容量的内容。只要提供页号就能在笔记本中进行定位。段就不一样了，段是我们写东西时自己定义的。这个笔记本上可能有很多段，一段中有很多内容，因此只提供段号无法找到段中的具体内容，必须知道段号和 段内偏移地址
页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率；或者说，分页仅仅是由于系统管理的需要，而不是用户的需要。

段是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好的满足用户的需要。

页的大小固定且由系统确定，把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而一个系统只能有一种大小的页面。段的长度却不固定，决定于用户所编写的程序，通常由编辑程序在对源程序进行编辑时，根据信息的性质来划分。

分页的作业地址空间是一维的，即单一的线性空间，程序员只须利用一个记忆符，即可表示一地址。分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。

---
### 8.说出你所知道的保持进程同步的方法？
进程间同步的主要方法有原子操作、信号量机制、自旋锁、管程、会合、分布式系统等。

---
### 9.Linux中常用到的命令
显示文件目录命令ls        如ls

改变当前目录命令cd        如cd /home

建立子目录mkdir           如mkdir xiong

删除子目录命令rmdir       如rmdir /mnt/cdrom

删除文件命令rm            如rm /ucdos.bat

文件复制命令cp            如cp /ucdos /fox

获取帮助信息命令man      如man ls

显示文件的内容less        如less mwm.lx

重定向与管道type          如type readme>>direct，将文件readme的内容追加到文direct中

---
### 10.makefile文件的作用是什么？
一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中。makefile定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作。因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。makefile带来的好处就是——“自动化编译”。一旦写好，只需要一个make命令，整个工程完全自动编译，极大地提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具。一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。

---
### 11.你知道操作系统的内容分为几块吗？什么叫做虚拟内存？他和主存的关系如何？内存管理属于操作系统的内容吗？
操作系统的主要组成部分：进程和线程的管理，存储管理，设备管理，文件管理。

虚拟内存是一些系统页文件，存放在磁盘上，每个系统页文件大小为4K，物理内存也被分页，每个页大小也为4K，这样虚拟页文件和物理内存页就可以对应，实际上虚拟内存就是用于物理内存的临时存放的磁盘空间。页文件就是内存页，物理内存中每页叫物理页，磁盘上的页文件叫虚拟页，物理页+虚拟页就是系统所有使用的页文件的总和。

---
### 12.线程是否具有相同的堆栈？dll是否有独立的堆栈？
每个线程有自己的堆栈。

dll是否有独立的堆栈？这个问题不好回答，或者说这个问题本身是否有问题。因为dll中的代码是被某些线程所执行，只有线程拥有堆栈。如果dll中的代码是exe中的线程所调用，那么这个时候是不是说这个dll没有独立的堆栈？如果dll中的代码是由dll自己创建的线程所执行，那么是不是说dll有独立的堆栈？

以上讲的是堆栈，如果对于堆来说，每个dll有自己的堆，所以如果是从dll中动态分配的内存，最好是从dll中删除；如果你从dll中分配内存，然后在exe中，或者另外一个dll中删除，很有可能导致程序崩溃。

---
### 13.什么是缓冲区溢出？有什么危害？其原因是什么？
缓冲区溢出是指当计算机向缓冲区内填充数据时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。

危害：在当前网络与分布式系统安全中，被广泛利用的50%以上都是缓冲区溢出，其中最著名的例子是1988年利用fingerd漏洞的蠕虫。而缓冲区溢出中，最为危险的是堆栈溢出，因为入侵者可以利用堆栈溢出，在函数返回时改变返回程序的地址，让其跳转到任意地址，带来的危害一种是程序崩溃导致拒绝服务，另外一种就是跳转并且执行一段恶意代码，比如得到shell，然后为所欲为。通过往程序的缓冲区写超出其长度的内容，造成缓冲区的溢出，从而破坏程序的堆栈，使程序转而执行其它指令，以达到攻击的目的。

造成缓冲区溢出的主原因是程序中没有仔细检查用户输入的参数。

---
### 14.什么是死锁？其条件是什么？怎样避免死锁？
死锁的概念：在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗地讲，就是两个或多个进程被无限期地阻塞、相互等待的一种状态。

死锁产生的原因主要是：？ 系统资源不足；？ 进程推进顺序非法。

产生死锁的必要条件：

（1）互斥（mutualexclusion），一个资源每次只能被一个进程使用；

（2）不可抢占（nopreemption），进程已获得的资源，在未使用完之前，不能强行剥夺；

（3）占有并等待（hold andwait），一个进程因请求资源而阻塞时，对已获得的资源保持不放；

（4）环形等待（circularwait），若干进程之间形成一种首尾相接的循环等待资源关系。

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

死锁的解除与预防：理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。

死锁的处理策略：鸵鸟策略、预防策略、避免策略、检测与恢复策略。

---
### 15.程序和进程
||定义|使用系统运行资源情况|
||||
|程序| 计算机指令的集合，它以文件的形式存储在磁盘上。程序是静态实体（passive Entity），在多道程序系统中，它是不能独立运行的，更不能与其他程序并发执行。| 不使用【程序不能申请系统资源，不能被系统调度，也不能作为独立运行的单位，因此，它不占用系统的运行资源】。 |
|进程| 通常被定义为一个正在运行的程序的实例，是一个程序在其自身的地址空间中的一次执行活动。</br>定义：进程是进程实体（包括：程序段、相关的数据段、进程控制块PCB）的运行过程，是系统进行资源分配和调度的一个独立单位。|使用【进程是资源申请、调度和独立运行的单位，因此，它使用系统中的运行资源。】|

---
### 16.进程与线程
如果说操作系统引入进程的目的是为了提高程序并发执行，以提高资源利用率和系统吞吐量。那么操作系统中引入线程的目的，则是为了减少进程并发执行过程中所付出的时空开销，使操作系统能很好的并发执行。

进程process定义了一个执行环境，包括它自己私有的地址空间、一个句柄表，以及一个安全环境；线程则是一个控制流，有他自己的调用栈call stack，记录了它的执行历史。

线程由两个部分组成：1）线程的内核对象，操作系统用它来对线程实施管理。内核对象也是系统用来存放线程统计信息的地方。2）线程堆栈，它用于维护线程在执行代码时需要的所有参数和局部变量。当创建线程时，系统创建一个线程内核对象。该线程内核对象不是线程本身，而是操作系统用来管理线程的较小的数据结构。可以将线程内核对象视为由关于线程的统计信息组成的一个小型数据结构。

---
## 17.进程同步
进程同步的主要任务：是对多个相关进程在执行次序上进行协调，以使并发执行的诸进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性。

同步机制遵循的原则：

（1）空闲让进；

（2）忙则等待（保证对临界区的互斥访问）；

（3）有限等待（有限代表有限的时间，避免死等）；

（4）让权等待，（当进程不能进入自己的临界区时，应该释放处理机，以免陷入忙等状态）。

---
### 18.进程间的通信是如何实现的？
进程通信，是指进程之间的信息交换（信息量少则一个状态或数值，多者则是成千上万个字节）。因此，对于用信号量(信号量是一个计数器，用来控制多个进程对资源的访问，它通常作为一种锁机制。)进行的进程间的互斥和同步，由于其所交换的信息量少而被归结为低级通信。

所谓高级进程通信指：用户可以利用操作系统所提供的一组通信命令传送大量数据的一种通信方式。操作系统隐藏了进程通信的实现细节。或者说，通信过程对用户是透明的。

高级通信机制可归结为三大类：

（1）共享存储器系统（存储器中划分的共享存储区）；实际操作中对应的是“剪贴板”（剪贴板实际上是系统维护管理的一块内存区域）的通信方式，比如举例如下：word进程按下ctrl+c，在ppt进程按下ctrl+v，即完成了word进程和ppt进程之间的通信，复制时将数据放入到剪贴板，粘贴时从剪贴板中取出数据，然后显示在ppt窗口上。

（2）消息传递系统（进程间的数据交换以消息（message）为单位，当今最流行的微内核操作系统中，微内核与服务器之间的通信，无一例外地都采用了消息传递机制。应用举例：邮槽（MailSlot）是基于广播通信体系设计出来的，它采用无连接的不可靠的数据传输。邮槽是一种单向通信机制，创建邮槽的服务器进程读取数据，打开邮槽的客户机进程写入数据。

（3）管道通信系统（管道即：连接读写进程以实现他们之间通信的共享文件（pipe文件，类似先进先出的队列，由一个进程写，另一进程读））。实际操作中，管道分为：匿名管道、命名管道。匿名管道是一个未命名的、单向管道，通过父进程和一个子进程之间传输数据。匿名管道只能实现本地机器上两个进程之间的通信，而不能实现跨网络的通信。命名管道不仅可以在本机上实现两个进程间的通信，还可以跨网络实现两个进程间的通信。

---
### 19.线程同步
||描述|内核对象/非内核对象|含义|缺点|适用|
|||||||
|关键代码段（临界区）CriticalSection||非内核对象，工作在用户方式下，为用户模式对象|从程序代码的角度来控制线程的并发性|1.因为在等待进入关键代码段时无法设定超时值，所以其很容易进入死锁状态。2.不能跨进程使用。|单个进程中线程间的同步（同步速度快）|
|事件对象Event|通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。|内核对象|所有内核对象中最基本的。|速度较慢（相比用户模式实现线程同步）|多个进程间的各个线程间实现同步|
|互斥对象Mutex|采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。|内核对象|代表对一个资源的独占式访问|速度较慢（相比用户模式实现线程同步）|多个进程间的各个线程间实现同步|
|信号量Semaphore|它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。|内核对象|使用计数器来控制程序对一个共享资源的访问|速度较慢（相比用户模式实现线程同步）|多个进程间的各个线程间实现同步|

由于进程同步产生了一系列经典的同步问题“生产者-消费者”问题，“哲学家进餐”问题，“读者-写者”问题。

---
### 20.进程有哪几种状态？
就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源

运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数

阻塞状态： 进程等待某种条件，在条件满足之前无法执行

---
### 21.操作系统中进程调度策略有哪几种？
FCFS(先来先服务)，优先级，时间片轮转，多级反馈

---
### 22.